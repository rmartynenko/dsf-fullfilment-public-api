#Область ПрограммныйИнтерфейс

Функция НовыеПараметрыОтветаНаВходящийЗапрос() Экспорт
	
	Сведения = Новый Структура;
	
	Сведения.Вставить("КодОтвета", 200);
	Сведения.Вставить("СодержимоеОтвета", "");
	Сведения.Вставить("Заголовки", Новый Соответствие);
	
	Возврат Сведения;
	
КонецФункции

// Функция - Ответ при ошибке разбора содержимого входящего запроса
//
// Параметры:
//  Запрос				 - 	 - 
//  СлужебныеПараметры	 - Структура - см. dsf_ВходящиеЗапросыЯндексМаркет.СлужебныеПараметрыВходящегоЗапроса
// 
// Возвращаемое значение:
//   - см. dsf_ВходящиеЗапросыЯндексМаркет.НовыеПараметрыОтветаНаВходящийЗапрос
//
Функция ОшибкаРазбораСодержимогоВходящегоЗапроса(СлужебныеПараметры, Ошибки) Экспорт
	
	ОтветНаЗапрос = НовыеПараметрыОтветаНаВходящийЗапрос();

	ЗаголовкиHTTP = ОтветНаЗапрос.Заголовки;
	
	ЗаголовкиHTTP.Вставить("X-1C-Error", "Request syntax error");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/xml; charset=utf-8");
	
	Ответ = дсфОбменДаннымиXDTOЯндексМаркет.КорневойЭлементСодержимогоОтвета(СлужебныеПараметры["ИдентификаторЗапроса"]);
	
	Ответ.response = дсфОбменДаннымиXDTOЯндексМаркет.ПустойОтвет(СлужебныеПараметры["ТипЗапроса"]);
	Ответ.requestState = дсфОбработкаОшибокЯндексМаркет.ОшибкиОбработкиЗапросаВXdtoОбъект(Ошибки);
	
	ОтветНаЗапрос.СодержимоеОтвета = СодержимоеОтветаВСтрокуXML(Ответ); 
	
	Возврат ОтветНаЗапрос;

КонецФункции

Функция ОшибкаАвторизацииПоТокенуДоступа(СлужебныеПараметры) Экспорт
	
	ОтветНаЗапрос = НовыеПараметрыОтветаНаВходящийЗапрос();

	ЗаголовкиHTTP = ОтветНаЗапрос.Заголовки;
	
	ЗаголовкиHTTP.Вставить("X-1C-Error", "Request processing error");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/xml; charset=utf-8");
	
	Ошибки = Новый Массив;
	ОшибкаАвторизации = дсфОбработкаОшибокЯндексМаркет.НеверныйТокенАвторизацииОшибка();
	Ошибки.Добавить(ОшибкаАвторизации);
	
	Ответ = дсфОбменДаннымиXDTOЯндексМаркет.КорневойЭлементСодержимогоОтвета(СлужебныеПараметры["ИдентификаторЗапроса"]);
	
	Ответ.response = дсфОбменДаннымиXDTOЯндексМаркет.ПустойОтвет(СлужебныеПараметры["ТипЗапроса"]);
	Ответ.requestState = дсфОбработкаОшибокЯндексМаркет.ОшибкиОбработкиЗапросаВXdtoОбъект(Ошибки);
	
	ОтветНаЗапрос.СодержимоеОтвета = СодержимоеОтветаВСтрокуXML(Ответ); 
	
	Возврат ОтветНаЗапрос;

КонецФункции

Функция ОшибкаПроверкиИдемпотентностиЗапроса(СлужебныеПараметры, Ошибки) Экспорт
	
	ОтветНаЗапрос = НовыеПараметрыОтветаНаВходящийЗапрос();

	ЗаголовкиHTTP = ОтветНаЗапрос.Заголовки;
	
	ЗаголовкиHTTP.Вставить("X-1C-Error", "Request idempotence key verification error");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/xml; charset=utf-8");
		
	Ответ = дсфОбменДаннымиXDTOЯндексМаркет.КорневойЭлементСодержимогоОтвета(СлужебныеПараметры["ИдентификаторЗапроса"]);
	
	Ответ.response = дсфОбменДаннымиXDTOЯндексМаркет.ПустойОтвет(СлужебныеПараметры["ТипЗапроса"]);
	Ответ.requestState = дсфОбработкаОшибокЯндексМаркет.ОшибкиОбработкиЗапросаВXdtoОбъект(Ошибки);
	
	ОтветНаЗапрос.СодержимоеОтвета = СодержимоеОтветаВСтрокуXML(Ответ); 
	
	Возврат ОтветНаЗапрос;

КонецФункции

Функция ОшибкаОбработкиЗапроса(СлужебныеПараметры, Ошибки) Экспорт
	
	ОтветНаЗапрос = НовыеПараметрыОтветаНаВходящийЗапрос();

	ЗаголовкиHTTP = ОтветНаЗапрос.Заголовки;
	
	ЗаголовкиHTTP.Вставить("X-1C-Error", "Request processing error");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/xml; charset=utf-8");
		
	Ответ = дсфОбменДаннымиXDTOЯндексМаркет.КорневойЭлементСодержимогоОтвета(СлужебныеПараметры["ИдентификаторЗапроса"]);
	
	Ответ.response = дсфОбменДаннымиXDTOЯндексМаркет.ПустойОтвет(СлужебныеПараметры["ТипЗапроса"]);
	Ответ.requestState = дсфОбработкаОшибокЯндексМаркет.ОшибкиОбработкиЗапросаВXdtoОбъект(Ошибки);
	
	ОтветНаЗапрос.СодержимоеОтвета = СодержимоеОтветаВСтрокуXML(Ответ); 
	
	Возврат ОтветНаЗапрос;

КонецФункции

// Функция - Ошибка несоответствия типа запроса вызываемому url
//
// Параметры:
//  Ошибки	 - Массив - см. dsf_ОбработкаОшибок.НоваяОшибкаПриВыполненииЗапросаЯндексМаркет
// 
// Возвращаемое значение:
//   - см. dsf_ВходящиеЗапросыЯндексМаркет.НовыеПараметрыОтветаНаВходящийЗапрос
//
Функция ОшибкаНесоответствияТипаЗапросаВызываемомуUrl(Ошибки) Экспорт
	
	ОтветНаЗапрос = НовыеПараметрыОтветаНаВходящийЗапрос();

	ЗаголовкиHTTP = ОтветНаЗапрос.Заголовки;
	
	ЗаголовкиHTTP.Вставить("X-1C-Error", "Url being called does not match the type of request.");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/xml; charset=utf-8");
	
	Ответ = дсфОбработкаОшибокЯндексМаркет.ОшибкиОбработкиЗапросаВXdtoОбъект(Ошибки);
	
	ОтветНаЗапрос.СодержимоеОтвета = СодержимоеОтветаВСтрокуXML(Ответ); 
	
	Возврат ОтветНаЗапрос;

КонецФункции

Функция ОтветНаЗапрос(СодержимоеОтвета, СлужебныеПараметры, Ошибки = Неопределено) Экспорт

	ОтветНаЗапрос = НовыеПараметрыОтветаНаВходящийЗапрос();

	ЗаголовкиHTTP = ОтветНаЗапрос.Заголовки;
	ЗаголовкиHTTP.Вставить("Content-Type", "application/xml; charset=utf-8");
		
	Ответ = дсфОбменДаннымиXDTOЯндексМаркет.КорневойЭлементСодержимогоОтвета(СлужебныеПараметры["ИдентификаторЗапроса"]);
	
	Ответ.response = СодержимоеУзлаResponse(СодержимоеОтвета, СлужебныеПараметры["ТипЗапроса"], Ошибки);
	Ответ.requestState = дсфОбработкаОшибокЯндексМаркет.ОшибкиОбработкиЗапросаВXdtoОбъект(Ошибки);
	
	ОтветНаЗапрос.СодержимоеОтвета = СодержимоеОтветаВСтрокуXML(Ответ); 

	Возврат ОтветНаЗапрос;
	
КонецФункции	

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция СодержимоеУзлаResponse(СодержимоеОтвета, ТипЗапроса, Ошибки) Экспорт
	
	ОтветXdto = дсфОбменДаннымиXDTOЯндексМаркет.ПустойОтвет(ТипЗапроса);
	
	Если ТипЗапроса = "putInbound" Тогда
		ОтветXdto["inboundId"] = СодержимоеОтвета;
		
	ИначеЕсли ТипЗапроса = "putInboundRegistry" Тогда
		ОтветXdto["registryId"] = СодержимоеОтвета;
		
	ИначеЕсли ТипЗапроса = "getInboundsStatus" Тогда
		ОтветXdto["inboundsStatus"] = СодержимоеОтвета;
		
	ИначеЕсли ТипЗапроса = "getInboundHistory" Тогда
		// историю статусов пишем (почему-то) сразу в Response, без собственного узла,
		// но в содержимом ответа придет InboundStatusHistories - Список XDTO, нужно обойти его элементы и добавить
		// в результат
		ИсторияСтатусовСписокXdto = СодержимоеОтвета["inboundStatusHistory"];
	
		Для каждого ЭлементИсторииСтатусов Из ИсторияСтатусовСписокXdto Цикл
			ОтветXdto["inboundStatusHistory"].Добавить(ЭлементИсторииСтатусов);

		КонецЦикла;

	ИначеЕсли ТипЗапроса = "getInbound" Тогда
		// в СодержимоеОтвета для данного запроса вернётся структура с двумя объектами XDTO
		// т.к. по описанию формата ответа их не объединяют в общий узел
		Если СодержимоеОтвета["inbound"] <> Неопределено Тогда
			ОтветXdto["inbound"] = СодержимоеОтвета["inbound"];
			
		КонецЕсли;

		Если СодержимоеОтвета["registries"] <> Неопределено Тогда
			ОтветXdto["registries"] = СодержимоеОтвета["registries"];
			
		КонецЕсли;
		
	ИначеЕсли ТипЗапроса = "putOutbound" Тогда
		ОтветXdto["outboundId"] = СодержимоеОтвета;
		
	ИначеЕсли ТипЗапроса = "putOutboundRegistry" Тогда
		ОтветXdto["registryId"] = СодержимоеОтвета;
		
	ИначеЕсли ТипЗапроса = "getOutboundsStatus" Тогда
		ОтветXdto["outboundsStatus"] = СодержимоеОтвета;
		
	ИначеЕсли ТипЗапроса = "getOutboundHistory" Тогда
		// историю статусов пишем (почему-то) сразу в Response, без собственного узла,
		// но в содержимом ответа придет OutboundStatusHistories - Список XDTO, нужно обойти его элементы и добавить
		// в результат
		ИсторияСтатусовСписокXdto = СодержимоеОтвета["outboundStatusHistory"];
	
		Для каждого ЭлементИсторииСтатусов Из ИсторияСтатусовСписокXdto Цикл
			ОтветXdto["outboundStatusHistory"].Добавить(ЭлементИсторииСтатусов);

		КонецЦикла;
		
	ИначеЕсли ТипЗапроса = "getOutbound" Тогда
		// в СодержимоеОтвета для данного запроса вернётся структура с двумя объектами XDTO
		// т.к. по описанию формата ответа их не объединяют в общий узел
		Если СодержимоеОтвета["outbound"] <> Неопределено Тогда
			ОтветXdto["outbound"] = СодержимоеОтвета["outbound"];
			
		КонецЕсли;

		Если СодержимоеОтвета["registries"] <> Неопределено Тогда
			ОтветXdto["registries"] = СодержимоеОтвета["registries"];
			
		КонецЕсли;

	ИначеЕсли ТипЗапроса = "getStocks" Тогда
		ОтветXdto["itemStocksList"] = СодержимоеОтвета;

	КонецЕсли;

	Возврат ОтветXdto;
	
КонецФункции

Функция СодержимоеОтветаВСтрокуXML(ОбъектXdto) Экспорт

	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку("UTF-8"); // запись в строку
	Запись.ЗаписатьОбъявлениеXML();
	
	ФабрикаXDTO.ЗаписатьXML(Запись, ОбъектXdto);
	ДанныеXML = Запись.Закрыть();
	
	// записываем с пустым пространством имен
	ДанныеXML = дсфОбщегоНазначенияЯндексМаркет.XMLСтрокаБезПространствИмен(ДанныеXML);
	
	Возврат ДанныеXML;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции
// Код процедур и функций
#КонецОбласти