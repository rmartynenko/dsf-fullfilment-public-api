#Область ПрограммныйИнтерфейс

// Проверяет наличие свойства у объекта XDTO. Возвращает Истина, если свойство присутствует.
//
// Параметры:
//  ОбъектXDTO	 - 	 - 
//  ИмяСвойства	 - 	 - 
// 
// Возвращаемое значение:
//   - Булево: Истина - свойство присутствует
//
Функция ЕстьСвойствоОбъектаXDTO(ОбъектXDTO, ИмяСвойства) Экспорт

	Возврат ОбъектXDTO.Свойства().Получить(ИмяСвойства) <> Неопределено;

КонецФункции

// Возвращает значение свойства объекта XDTO.
//
// Параметры:
//   ОбъектXDTO - ОбъектXDTO, из которого необходимо прочитать значение ключа.
//   ИмяСвойства - Строка - имя свойства объекта XDTO, для которого необходимо прочитать значение.
//   ЗначениеПоУмолчанию - Произвольный - возвращается когда в объекте нет значения по указанному
//                                        ключу.
//       Для скорости рекомендуется передавать только быстро вычисляемые значения (например примитивные типы),
//       а инициализацию более тяжелых значений выполнять после проверки полученного значения (только если это
//       требуется).
//
// Возвращаемое значение:
//   Произвольный - значение свойства xdto. ЗначениеПоУмолчанию если в xdto нет указанного свойства.
//
Функция ЗначениеСвойстваXdto(ОбъектXDTO, ИмяСвойства, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если ОбъектXDTO = Неопределено Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	СвойствоXdto = ОбъектXDTO.Свойства().Получить(ИмяСвойства);
	
	Если СвойствоXdto <> Неопределено Тогда
		Возврат ОбъектXDTO[СвойствоXdto.Имя];
	Иначе
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
КонецФункции

Функция ИнтервалДатИзСтроки(ИнтервалСтрокой, РазделительДат = "/", УчитыватьГраницуОкончания = Ложь) Экспорт
	
	Интервал = Новый Структура("НачалоИнтервала,ОкончаниеИнтервала", Неопределено, Неопределено);

	СтрокиПериодов = СтрРазделить(ИнтервалСтрокой, РазделительДат);
	
	Если СтрокиПериодов.Количество() = 2 Тогда
	
		ДатаНачалаИнтервала = XMLЗначение(Тип("Дата"), СтрокиПериодов[0]);	
		Интервал.НачалоИнтервала = ДатаНачалаИнтервала;
		
		ДатаОкончанияИнтервала = XMLЗначение(Тип("Дата"), СтрокиПериодов[1]);
		
		Если ЗначениеЗаполнено(ДатаОкончанияИнтервала) Тогда
		//	Интервал.ОкончаниеИнтервала = ?(Не УчитыватьГраницуОкончания, ДатаОкончанияИнтервала - 1, ДатаОкончанияИнтервала);
			Интервал.ОкончаниеИнтервала = ДатаОкончанияИнтервала;
			
		КонецЕсли;
	
	КонецЕсли;
	
	Возврат Интервал;
	
КонецФункции

Функция ДатаИзСтроки(ДатаСтрокой) Экспорт
	
	Возврат XMLЗначение(Тип("Дата"), ДатаСтрокой);
	
КонецФункции

// Возвращает таблицу значений на основании массива структур
//
// Параметры:
// МассивСтруктур - Массив Из Структура - Массив структур, которые будут преобразованы в таблиц значений.
//    Свойства структуры первого элемента массива определяют состав колонок результирующей таблицы.
//
// Возвращаемое значение:
// ТаблицаЗначений - таблица значений, созданная из массива структур.
//
Функция ПреобразоватьМассивВТаблицуЗначений(МассивСтруктур) Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	
	// Создадим колонки по первой структуре массива
	Если ТипЗнч(МассивСтруктур) = Тип("Массив")
		И МассивСтруктур.Количество() <> 0 Тогда
		ПерваяСтруктура = МассивСтруктур[0];
		Для Каждого Свойство Из ПерваяСтруктура Цикл
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
			
		КонецЦикла;
		
		Для Каждого Структура Из МассивСтруктур Цикл
			НоваяСтрока = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Структура);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция ОбъемПоГабаритам(Ширина = 0, Длина = 0, Высота = 0, КоэффициентПересчетаОбъема) Экспорт
	
	Возврат СлужебныйКлиентСервер.ОбъемПоРазмерам(Ширина, Длина, Высота, КоэффициентПересчетаОбъема);
	
КонецФункции

// устарела, использовать дсфОбщегоНазначенияАпиПовтИсп.ЕдиницаИзмеренияШтук
Функция ЕдиницаИзмеренияШтук() Экспорт
	
	Возврат дсфОбщегоНазначенияАпиПовтИсп.ЕдиницаИзмеренияШтук();
	
КонецФункции

Функция ПолучитьПеречислениеПоИмени(Знач ТипПеречисления, Знач ИмяПеречисления) Экспорт
	
	Перем Результат;
	
	МетаданныеПеречисления = Метаданные.Перечисления.Найти(ТипПеречисления);
	Если МетаданныеПеречисления <> Неопределено Тогда
		МетаданныеЗначенияПеречисления = МетаданныеПеречисления.ЗначенияПеречисления.Найти(ИмяПеречисления);
		Если МетаданныеЗначенияПеречисления <> Неопределено Тогда
			Результат = Перечисления[ТипПеречисления][ИмяПеречисления];
		Иначе
			Результат = Перечисления[ТипПеречисления].ПустаяСсылка();
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ПроцессПоступленияПоУмолчанию() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ПроцессПоступления = Константы.дсфОсновнойПроцессПоступления.Получить();
	
	Возврат ПроцессПоступления;
	
КонецФункции 

Функция ТипМестаХраненияДляПалетПоУмолчанию() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипМестаХранения = Константы.дсфТипМестаХраненияДляПалет.Получить();
	
	Возврат ТипМестаХранения;
	
КонецФункции

Функция ТипМестаХраненияДляКоробовПоУмолчанию() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипМестаХранения = Константы.дсфТипМестаХраненияДляКоробов.Получить();
	
	Возврат ТипМестаХранения;
	
КонецФункции

// Возвращает описание типов по переданному типу
//
// Параметры:
//    Тип - Тип - Тип значения
//
// Возвращаемое значение:
//    ОписаниеТипов - созданное на основании переданного типа описание типов.
//
Функция ОписаниеТиповПоТипу(Тип) Экспорт

	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип);

	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);

	Возврат ОписаниеТипов;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#КонецОбласти